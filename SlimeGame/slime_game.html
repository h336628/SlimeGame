<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é­”ç‹å¯µç‰©å²èŠå§†ï¼šç§˜å¯†æ½›è¡Œ</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            color: white;
            font-family: "Microsoft JhengHei", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        h1 { margin: 10px 0; font-size: 24px; color: #ffcc00; text-shadow: 2px 2px 0 #5c0000; }
        p { margin: 5px 0; color: #aaa; font-size: 14px; }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 4px solid #444;
            border-radius: 4px;
        }

        canvas {
            background-color: #1a1a1a;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10;
            text-align: center;
        }

        .hidden { display: none !important; }

        button {
            background: #8b0000;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: transform 0.1s;
            font-family: inherit;
            border: 2px solid #ff4d4d;
        }
        button:hover { transform: scale(1.05); background: #a00000; }
        
        .npc-portrait { width: 64px; height: 64px; image-rendering: pixelated; border-radius: 50%; background: #444; margin-bottom: 10px; border: 2px solid white;}
        #fail-reason { font-size: 18px; max-width: 80%; line-height: 1.5; color: #ffcccc; }
    </style>
</head>
<body>

    <h1>ğŸ° é­”ç‹å¯µç‰©å²èŠå§†ï¼šç§˜å¯†æ½›è¡Œ</h1>
    <p>èº²é¿è¦–ç·š | è«çˆ¾è¿ªæ–¯æ¯2ç§’æœƒç¬ç§» | å·¦ä¸Šè§’ç‚ºå®‰å…¨å€ | ç›®æ¨™ï¼šå³ä¸‹è§’é­”ç‹æˆ¿é–“</p>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- UI ä»‹é¢ -->
        <div id="ui-layer">
            <div id="start-screen">
                <img src="Slime.png" style="width:80px; image-rendering: pixelated;">
                <h2>å²èŠå§†çš„ç™‚ç™’å¤§ä½œæˆ°</h2>
                <p>é­”ç‹å¤§äººæ­£ç‚ºäº†åŸå ¡ç ´çˆ›è€Œç…©æƒ±...<br>èº«ç‚ºè²¼å¿ƒå¯µç‰©çš„ä½ ï¼Œæ±ºå®šæ½›å…¥é­”ç‹æˆ¿é–“çµ¦ä»–ä¸€å€‹æ“æŠ±ï¼<br>ä½†æ˜¯...åƒè¬åˆ¥è¢«é‚£äº›ç¥ç¶“è³ªçš„éƒ¨ä¸‹ç™¼ç¾äº†ï¼</p>
                <button onclick="startGame()">é–‹å§‹æ½›è¡Œ</button>
            </div>
            
            <div id="game-over-screen" class="hidden">
                <img id="fail-portrait" class="npc-portrait" src="">
                <h2 style="color: #ff4d4d">è¢«ç™¼ç¾äº†ï¼</h2>
                <p id="fail-reason">NPC å°è©...</p>
                <button onclick="startGame()">é‡æ–°æŒ‘æˆ°</button>
            </div>

            <div id="win-screen" class="hidden">
                <img src="Slime.png" style="width:80px; image-rendering: pixelated;">
                <h2 style="color: #ffcc00">ä»»å‹™å®Œæˆï¼</h2>
                <p>ä½ æˆåŠŸé‘½é€²äº†é­”ç‹å¤§äººçš„æ‡·è£¡ï¼<br>é­”ç‹å¤§äººè¢«ä½ çš„è»ŸQç™‚ç™’äº†ï¼Œå¿ƒæƒ…è®Šå¥½äº†ï¼</p>
                <button onclick="startGame()">å†ç©ä¸€æ¬¡</button>
            </div>
        </div>
    </div>

<script>
/**
 * éŠæˆ²è¨­å®šèˆ‡è³‡æºè¼‰å…¥
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// éŠæˆ²åƒæ•¸
const TILE_SIZE = 40;
const COLS = 20;
const ROWS = 15;
const PLAYER_SPEED = 3; 
const SAFE_ZONE_TILES = 4; // å·¦ä¸Šè§’å®‰å…¨å€å¤§å° (4x4)
const BOSS_ROOM_TILES = 4; // å³ä¸‹è§’é­”ç‹æˆ¿é–“å¤§å° (4x4)

// åœ–ç‰‡è³‡æºåº«
const assets = {
    slime: { src: 'Slime.png', img: null },
    aaron: { src: 'ARON.png', img: null },
    carlos: { src: 'CAROS.png', img: null },
    ed: { src: 'ed.png', img: null },
    elaine: { src: 'ELAN.png', img: null },
    mordees: { src: 'MORDEES.png', img: null }
};

let loadedCount = 0;
const totalAssets = Object.keys(assets).length;
for (let key in assets) {
    const img = new Image();
    img.src = assets[key].src;
    img.onload = () => { loadedCount++; };
    assets[key].img = img;
}

// éŠæˆ²ç‹€æ…‹
let gameState = 'MENU'; 
let map = []; // 0: åœ°æ¿, 1: ç‰†å£
let player = { x: 0, y: 0, vx: 0, vy: 0, invincible: false, invincibleTimer: 0 };
let npcs = [];
let mordees = { active: false, x: 0, y: 0, timer: 0, text: "", bubbleTimer: 0 };

// --- NPC è¨­å®šæª” (æ›´æ–°ï¼šç¢ç¢å¿µ bubbleTexts æ¸…å–®) ---
const NPC_CONFIG = {
    ED: { 
        name: 'è‰¾å¾·', speed: 0.8, fov: 70, range: 150, color: 'rgba(150, 100, 255, 0.3)', imgKey: 'ed', 
        bubbleTexts: ["é€™å€‹æœˆåˆè¦åƒåœŸäº†", "æˆ‘è©²æ‹¿ç§æˆ¿éŒ¢å‡ºä¾†å—ï¼Ÿ", "é‚£è£¡çš„ç‰†å£åˆå¡Œäº†â€¦"],
        msgs: [
            "ã€Œå²èŠå§†å¤§äººï¼Œæ‚¨é€™æ˜¯è¦å»å“ªå•Šï¼Ÿã€",
            "ã€Œå”‰ï¼Œåœ°æ¿åˆé«’äº†ï¼Œè«‹ä¸è¦éš¨è™•äº‚è·‘ã€‚ã€",
            "ã€Œç¾åœ¨ä¸æ˜¯ç©è€çš„æ™‚é–“ï¼Œè«‹å›å§ã€‚ã€"
        ]
    },
    CARLOS: { 
        name: 'å¡æ´›æ–¯', speed: 2.5, fov: 30, range: 180, color: 'rgba(255, 50, 50, 0.3)', imgKey: 'carlos', 
        bubbleTexts: ["æˆ‘è¦è®Šå¼·ï¼", "ä¸èƒ½å»æ‰¾é­”ç‹å¤§äººå—ï¼Ÿ", "è‚šå­å¥½é¤“å–”"],
        msgs: [
            "ã€Œä¸å‡†å»æ‰“æ“¾é­”ç‹å¤§äººï¼å›å»ï¼ã€",
            "ã€Œå“¼ï¼Œæƒ³æºœéå»ï¼Ÿé‚„æ—©äº†ä¸€ç™¾å¹´ï¼ã€",
            "ã€Œé€™è£¡ç¦æ­¢é€šè¡Œï¼å»å»å»ï¼Œä¸€é‚Šç©å»ã€‚ã€"
        ]
    },
    ELAINE: { 
        name: 'ä¼ŠèŠæ©', speed: 1.0, fov: 50, range: 160, color: 'rgba(100, 200, 255, 0.3)', imgKey: 'elaine', 
        bubbleTexts: ["é­”ç‹å¤§äººæœ‰åƒé£¯å—ï¼Ÿ", "è©²é€é»å¿ƒçµ¦é­”ç‹å¤§äºº", "é­”ç‹å¤§äººæœ‰ä¼‘æ¯å—ï¼Ÿ"],
        msgs: [
            "ã€Œå²èŠå§†å¤§äººï¼Œé€™è£¡ä¸èƒ½é€šéå–”â€¦â€¦ã€",
            "ã€Œç‚ºäº†å¤§äººçš„å®‰å¯§ï¼Œè«‹æ‚¨å®‰éœä¸€é»ã€‚ã€",
            "ã€Œé€™å¯ä¸è¡Œï¼Œè¢«ç™¼ç¾çš„è©±æˆ‘æœƒå¾ˆå›°æ“¾çš„ã€‚ã€"
        ]
    },
    AARON: { 
        name: 'å‹‡è€…äºå€«', speed: 1.5, fov: 45, range: 140, color: 'rgba(255, 200, 0, 0.3)', imgKey: 'aaron', 
        bubbleTexts: ["é€™è£¡æ˜¯å“ªè£¡ï¼Ÿ", "é­”ç‹çš„æˆ¿é–“åœ¨å“ªï¼Ÿ", "è¿·è·¯äº†â€¦â€¦"],
        msgs: [
            "ã€Œå—šå“‡ï¼å²èŠå§†ï¼...æŠ±æ­‰ï¼Œæˆ‘æ¢ä»¶åå°„æ‹”åŠäº†ã€‚ã€",
            "ã€Œæ¬¸ï¼Ÿç­‰ç­‰ï¼Œé­”ç‹çš„æˆ¿é–“æ˜¯åœ¨é€™é‚Šå—ï¼Ÿã€",
            "ã€Œåˆ¥æ“‹è·¯ï¼Œå°å‚¢ä¼™ï¼Œæˆ‘è¦å»è¨ä¼é­”ç‹ï¼ã€"
        ]
    }
};

const MORDEES_TEXTS = [
    "å¥½é–’å–”~",
    "å¥½ç„¡èŠå–”",
    "å°é­”ç‹ç¾åœ¨åœ¨åšä»€éº¼å‘€?",
    "å‘¼å“‡~ (æ‰“å“ˆæ¬ )",
    "é€™è£¡æœ‰è—å¯¶è—å—?",
    "å“å‘€ï¼Œè¢«ç™¼ç¾äº†å—?",
    "ç•¶å‰ä»»é­”ç‹çœŸè¼•é¬†~"
];

function startGame() {
    if (loadedCount < totalAssets) { alert("åœ–ç‰‡è¼‰å…¥ä¸­ï¼Œè«‹ç¨å¾Œ..."); return; }
    document.getElementById('ui-layer').classList.add('hidden');
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('win-screen').classList.add('hidden');

    generateMap();
    spawnEntities();
    
    gameState = 'PLAYING';
    gameLoop();
}

/**
 * åœ°åœ–ç”Ÿæˆ
 */
function generateMap() {
    map = [];
    for (let y = 0; y < ROWS; y++) {
        let row = [];
        for (let x = 0; x < COLS; x++) {
            // 1. é‚Šç•Œç‰†å£
            if (x === 0 || x === COLS - 1 || y === 0 || y === ROWS - 1) {
                row.push(1);
            } 
            // 2. é­”ç‹æˆ¿é–“ (å³ä¸‹è§’) åœç‰†
            else if (x === COLS - BOSS_ROOM_TILES && y >= ROWS - BOSS_ROOM_TILES) {
                // å…¥å£ï¼šåœ¨ y = ROWS - 2 çš„åœ°æ–¹é–‹æ´
                if (y === ROWS - 2) row.push(0);
                else row.push(1);
            }
            else if (y === ROWS - BOSS_ROOM_TILES && x >= COLS - BOSS_ROOM_TILES) {
                row.push(1);
            }
            else {
                // 3. ä¸€èˆ¬å€åŸŸ
                // ç¢ºä¿å®‰å…¨å€ (å·¦ä¸Š) å’Œ é­”ç‹æˆ¿é–“å…§éƒ¨ (å³ä¸‹) æ²’æœ‰éš¨æ©Ÿç‰†
                if (x < SAFE_ZONE_TILES && y < SAFE_ZONE_TILES) row.push(0); // å®‰å…¨å€
                else if (x > COLS - BOSS_ROOM_TILES && y > ROWS - BOSS_ROOM_TILES) row.push(0); // é­”ç‹æˆ¿é–“å…§
                else row.push(Math.random() < 0.2 ? 1 : 0); // éš¨æ©Ÿç‰†
            }
        }
        map.push(row);
    }
}

function spawnEntities() {
    player.x = TILE_SIZE * 1.5;
    player.y = TILE_SIZE * 1.5;
    player.invincible = false;
    player.invincibleTimer = 0;

    npcs = [];
    const availableTypes = [NPC_CONFIG.ED, NPC_CONFIG.CARLOS, NPC_CONFIG.ELAINE, NPC_CONFIG.AARON];
    // æ´—ç‰Œ
    for (let i = availableTypes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [availableTypes[i], availableTypes[j]] = [availableTypes[j], availableTypes[i]];
    }
    
    let count = 3 + Math.floor(Math.random() * 2); 
    for (let i = 0; i < count; i++) {
        let pos = getRandomFreePosition(false, false); 
        let type = availableTypes[i];
        
        npcs.push({
            x: pos.x, y: pos.y, type: type,
            angle: Math.random() * Math.PI * 2,
            moveTimer: 0, moveDir: Math.random() * Math.PI * 2,
            // ç¢ç¢å¿µç³»çµ±åˆå§‹åŒ–
            bubbleTimer: Math.random() * 120, // éš¨æ©Ÿåˆå§‹å»¶é²
            isBubbleVisible: false,
            currentBubbleText: ""
        });
    }

    // è«çˆ¾è¿ªæ–¯
    let mPos = getRandomFreePosition(false, true); 
    mordees = {
        active: true, x: mPos.x, y: mPos.y,
        timer: 120, text: getRandomText(), bubbleTimer: 60
    };
}

function getRandomText() {
    return MORDEES_TEXTS[Math.floor(Math.random() * MORDEES_TEXTS.length)];
}

function getRandomFreePosition(allowSafeZone, allowBossRoom) {
    let x, y;
    let maxAttempts = 100;
    do {
        x = Math.floor(Math.random() * (COLS - 2)) + 1;
        y = Math.floor(Math.random() * (ROWS - 2)) + 1;
        
        let inSafeZone = (x < SAFE_ZONE_TILES && y < SAFE_ZONE_TILES);
        let inBossRoom = (x >= COLS - BOSS_ROOM_TILES && y >= ROWS - BOSS_ROOM_TILES);

        if (!allowSafeZone && inSafeZone) continue;
        if (!allowBossRoom && inBossRoom) continue;
        
        if (map[y][x] !== 1) {
            return { x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2 };
        }
        maxAttempts--;
    } while (maxAttempts > 0);
    return { x: TILE_SIZE * 5, y: TILE_SIZE * 5 }; 
}

function gameLoop() {
    if (gameState !== 'PLAYING') return;
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

function update() {
    // --- ç©å®¶ç§»å‹• ---
    let nextX = player.x + player.vx * PLAYER_SPEED;
    let nextY = player.y + player.vy * PLAYER_SPEED;
    if (!isWall(nextX, player.y)) player.x = nextX;
    if (!isWall(player.x, nextY)) player.y = nextY;
    player.x = Math.max(20, Math.min(canvas.width - 20, player.x));
    player.y = Math.max(20, Math.min(canvas.height - 20, player.y));

    if (player.invincible) {
        player.invincibleTimer--;
        if (player.invincibleTimer <= 0) player.invincible = false;
    }

    // --- è«çˆ¾è¿ªæ–¯ ---
    if (mordees.active) {
        if (dist(player.x, player.y, mordees.x, mordees.y) < 30) {
            player.invincible = true;
            player.invincibleTimer = 120; 
            // ç¬ç§»
            let newPos = getRandomFreePosition(false, true);
            mordees.x = newPos.x; mordees.y = newPos.y;
            mordees.timer = 120;
            mordees.text = "å“å‘€~";
            mordees.bubbleTimer = 60;
        }

        mordees.timer--;
        if (mordees.timer <= 0) {
            // å®šæ™‚ç¬ç§»
            let newPos = getRandomFreePosition(false, true);
            mordees.x = newPos.x; mordees.y = newPos.y;
            mordees.timer = 120;
            mordees.text = getRandomText();
            mordees.bubbleTimer = 90;
        }
        if (mordees.bubbleTimer > 0) mordees.bubbleTimer--;
    }

    // --- å‹åˆ©æª¢æŸ¥ ---
    if (player.x > (COLS - 3) * TILE_SIZE && player.y > (ROWS - 3) * TILE_SIZE) {
        gameWin();
        return;
    }

    // --- NPC é‚è¼¯ ---
    for (let npc of npcs) {
        // AI ç§»å‹•
        npc.moveTimer--;
        if (npc.moveTimer <= 0) {
            npc.moveDir = Math.random() * Math.PI * 2;
            npc.moveTimer = 60 + Math.random() * 60;
        }
        let nx = npc.x + Math.cos(npc.moveDir) * npc.type.speed;
        let ny = npc.y + Math.sin(npc.moveDir) * npc.type.speed;
        
        if (isValidNpcPos(nx, ny)) {
            npc.x = nx;
            npc.y = ny;
            let targetAngle = npc.moveDir;
            npc.angle = lerpAngle(npc.angle, targetAngle, 0.1);
        } else {
            npc.moveTimer = 0; 
        }

        // --- ç¢ç¢å¿µæ°£æ³¡é‚è¼¯ ---
        npc.bubbleTimer--;
        if (npc.bubbleTimer <= 0) {
            if (npc.isBubbleVisible) {
                // éš±è—æ°£æ³¡
                npc.isBubbleVisible = false;
                npc.bubbleTimer = 120 + Math.random() * 120; // æ²‰é»˜ 2-4 ç§’
            } else {
                // é¡¯ç¤ºæ–°æ°£æ³¡
                npc.isBubbleVisible = true;
                // å¾æ¸…å–®ä¸­éš¨æ©Ÿé¸ä¸€å¥
                let texts = npc.type.bubbleTexts;
                npc.currentBubbleText = texts[Math.floor(Math.random() * texts.length)];
                npc.bubbleTimer = 120; // é¡¯ç¤º 2 ç§’
            }
        }

        // åµæ¸¬
        if (!player.invincible) {
            let playerInSafeZone = (player.x < SAFE_ZONE_TILES * TILE_SIZE && player.y < SAFE_ZONE_TILES * TILE_SIZE);
            if (!playerInSafeZone) {
                if (checkDetection(npc, player)) {
                    gameOver(npc);
                    return;
                }
                if (dist(player.x, player.y, npc.x, npc.y) < 25) {
                    gameOver(npc);
                    return;
                }
            }
        }
    }
}

function isValidNpcPos(x, y) {
    if (isWall(x, y)) return false;
    // ç¦å€ï¼šå®‰å…¨å€ & é­”ç‹æˆ¿
    if (x < SAFE_ZONE_TILES * TILE_SIZE && y < SAFE_ZONE_TILES * TILE_SIZE) return false;
    if (x > (COLS - BOSS_ROOM_TILES) * TILE_SIZE && y > (ROWS - BOSS_ROOM_TILES) * TILE_SIZE) return false;
    return true;
}

function draw() {
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ç¹ªè£½åœ°åœ–
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            let px = x * TILE_SIZE;
            let py = y * TILE_SIZE;
            if (map[y][x] === 1) {
                ctx.fillStyle = '#444';
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = '#222';
                ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
            } else {
                ctx.strokeStyle = '#2a2a2a';
                if (x < SAFE_ZONE_TILES && y < SAFE_ZONE_TILES) ctx.fillStyle = '#1a2a1a'; 
                else if (x > COLS - BOSS_ROOM_TILES && y > ROWS - BOSS_ROOM_TILES) ctx.fillStyle = '#2a1a1a'; 
                else ctx.fillStyle = '#1a1a1a';
                
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // çµ‚é»
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.fillText("é­”ç‹æˆ¿é–“", (COLS-2.5)*TILE_SIZE, (ROWS-2.5)*TILE_SIZE);

    // è«çˆ¾è¿ªæ–¯
    if (mordees.active) {
        ctx.drawImage(assets.mordees.img, mordees.x - 16, mordees.y - 16, 32, 32);
        drawBubble(mordees.x, mordees.y, mordees.text, mordees.bubbleTimer > 0);
    }

    // NPC
    for (let npc of npcs) {
        if (!player.invincible) drawVisionCone(npc);
        
        ctx.save();
        ctx.translate(npc.x, npc.y);
        if (Math.cos(npc.angle) < 0) ctx.scale(-1, 1);
        ctx.drawImage(assets[npc.type.imgKey].img, -20, -20, 40, 40);
        ctx.restore();

        // ç¢ç¢å¿µæ°£æ³¡
        drawBubble(npc.x, npc.y, npc.currentBubbleText, npc.isBubbleVisible, false);
    }

    // ç©å®¶
    ctx.save();
    ctx.translate(player.x, player.y);
    if (player.invincible) {
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, 25, 0, Math.PI*2);
        ctx.strokeStyle = 'gold';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText((player.invincibleTimer/60).toFixed(1), -10, -25);
    }
    let scale = 1 + Math.sin(Date.now() / 100) * 0.05;
    ctx.scale(scale, 1/scale);
    ctx.drawImage(assets.slime.img, -16, -16, 32, 32);
    ctx.restore();
    
    // å®‰å…¨å€æç¤º
    if (player.x < SAFE_ZONE_TILES * TILE_SIZE && player.y < SAFE_ZONE_TILES * TILE_SIZE) {
        ctx.fillStyle = '#4caf50';
        ctx.font = 'bold 16px Microsoft JhengHei';
        ctx.fillText("å®‰å…¨å€", 20, 30);
    }
}

// ç¹ªè£½æ°£æ³¡
function drawBubble(x, y, text, visible, isPermanent = false) {
    if (!visible || !text) return;
    
    ctx.save();
    ctx.font = '10px Microsoft JhengHei';
    let width = ctx.measureText(text).width + 8;
    let height = 16;
    let yOffset = -40; 

    // èƒŒæ™¯
    ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
    ctx.fillRect(x - width/2, y + yOffset, width, height);
    ctx.strokeStyle = '#333';
    ctx.strokeRect(x - width/2, y + yOffset, width, height);
    
    // æ–‡å­—
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y + yOffset + height/2);
    
    // ä¸‰è§’å½¢
    ctx.beginPath();
    ctx.moveTo(x, y + yOffset + height);
    ctx.lineTo(x - 4, y + yOffset + height + 4);
    ctx.lineTo(x + 4, y + yOffset + height);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
    ctx.fill();
    ctx.stroke(); // å¹«ç®­é ­ä¹ŸåŠ é‚Šæ¡†
    ctx.restore();
}

function isWall(x, y) {
    let gx = Math.floor(x / TILE_SIZE);
    let gy = Math.floor(y / TILE_SIZE);
    if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return true;
    return map[gy][gx] === 1;
}

function drawVisionCone(npc) {
    ctx.save();
    ctx.translate(npc.x, npc.y);
    ctx.rotate(npc.angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    let halfFov = (npc.type.fov * Math.PI / 180) / 2;
    ctx.arc(0, 0, npc.type.range, -halfFov, halfFov);
    ctx.closePath();
    ctx.fillStyle = npc.type.color;
    ctx.fill();
    ctx.restore();
}

function checkDetection(npc, player) {
    let d = dist(npc.x, npc.y, player.x, player.y);
    if (d > npc.type.range) return false;

    let dx = player.x - npc.x;
    let dy = player.y - npc.y;
    let angleToPlayer = Math.atan2(dy, dx);
    let angleDiff = angleToPlayer - npc.angle;
    while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

    let halfFov = (npc.type.fov * Math.PI / 180) / 2;
    
    if (Math.abs(angleDiff) <= halfFov) {
        let steps = Math.ceil(d / 10); 
        for (let i = 1; i < steps; i++) {
            let t = i / steps;
            let checkX = npc.x + dx * t;
            let checkY = npc.y + dy * t;
            if (isWall(checkX, checkY)) return false;
        }
        return true;
    }
    return false;
}

function dist(x1, y1, x2, y2) { return Math.sqrt((x1-x2)**2 + (y1-y2)**2); }
function lerpAngle(a, b, t) {
    let diff = b - a;
    while (diff <= -Math.PI) diff += Math.PI * 2;
    while (diff > Math.PI) diff -= Math.PI * 2;
    return a + diff * t;
}

function gameOver(npc) {
    gameState = 'GAMEOVER';
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('fail-portrait').src = assets[npc.type.imgKey].src;
    let randomMsg = npc.type.msgs[Math.floor(Math.random() * npc.type.msgs.length)];
    document.getElementById('fail-reason').innerText = randomMsg;
}

function gameWin() {
    gameState = 'WIN';
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('win-screen').classList.remove('hidden');
}

const keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; updatePlayerVel(); });
window.addEventListener('keyup', e => { keys[e.key] = false; updatePlayerVel(); });
function updatePlayerVel() {
    player.vx = 0; player.vy = 0;
    if (keys['ArrowUp'] || keys['w']) player.vy = -1;
    if (keys['ArrowDown'] || keys['s']) player.vy = 1;
    if (keys['ArrowLeft'] || keys['a']) player.vx = -1;
    if (keys['ArrowRight'] || keys['d']) player.vx = 1;
}
</script>
</body>
</html>