<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é­”ç‹å¯µç‰©å²èŠå§†ï¼šç§˜å¯†æ½›è¡Œå¤§ä½œæˆ°</title>
    <style>
        /* --- åŸºç¤æ¨£å¼ --- */
        body {
            margin: 0;
            background-color: #222;
            color: white;
            font-family: "Microsoft JhengHei", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* ç¦æ­¢é è¨­è§¸æ§è¡Œç‚º */
        }

        h1 { margin: 10px 0; font-size: 20px; color: #ffcc00; text-shadow: 2px 2px 0 #5c0000; text-align: center; }
        p { margin: 5px 0; color: #aaa; font-size: 12px; text-align: center; }

        /* --- éŠæˆ²å®¹å™¨èˆ‡ç•«å¸ƒ --- */
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #444;
            border-radius: 4px;
            width: 95vw;
            max-width: 800px;
            aspect-ratio: 4/3; 
            overflow: hidden;
        }

        canvas {
            background-color: #1a1a1a;
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UI å±¤ --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden { display: none !important; }

        /* --- æŒ‰éˆ•æ¨£å¼ --- */
        button {
            background: #8b0000;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 15px;
            transition: transform 0.1s;
            font-family: inherit;
            border: 2px solid #ff4d4d;
            box-shadow: 0 4px 0 #500;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #500; }
        
        .npc-portrait { width: 64px; height: 64px; image-rendering: pixelated; border-radius: 50%; background: #444; margin-bottom: 10px; border: 2px solid white;}
        #fail-reason { font-size: 16px; max-width: 90%; line-height: 1.5; color: #ffcccc; }

        /* --- è™›æ“¬æ–æ¡¿ (æ‰‹æ©Ÿç‰ˆå°ˆç”¨) --- */
        #joystick-zone {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none; 
            z-index: 10;
            touch-action: none;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 204, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
        }

        /* åŠŸèƒ½æŒ‰éˆ• (å…¨è¢å¹• / é‡ç½®) */
        .control-btn {
            position: fixed;
            top: 10px;
            background: rgba(0,0,0,0.5);
            border: 1px solid white;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            z-index: 100;
            border-radius: 4px;
            margin: 0;
            box-shadow: none;
            cursor: pointer;
        }
        #fullscreen-btn { right: 10px; }
        #reset-btn { left: 10px; display: none; } /* é è¨­éš±è—ï¼Œé–‹å§‹éŠæˆ²å¾Œé¡¯ç¤º */

        @media (max-width: 600px) {
            h1 { font-size: 18px; margin-top: 5px; }
            #game-container {
                width: 100%;
                border-left: none;
                border-right: none;
                border-radius: 0;
                aspect-ratio: auto; 
                flex: 1; 
            }
            #joystick-zone { display: block; bottom: 30px; }
        }
    </style>
</head>
<body>

    <button id="reset-btn" class="control-btn" onclick="resetMap()">ğŸ”„ åˆ·æ–°åœ°åœ–</button>
    <button id="fullscreen-btn" class="control-btn" onclick="toggleFullScreen()">å…¨è¢å¹•</button>
    
    <h1>ğŸ° The Demon Lord's Pet: Slime Sneak</h1>
    <p>é›»è…¦ï¼šæ–¹å‘éµç§»å‹• | æ‰‹æ©Ÿï¼šè™›æ“¬æ–æ¡¿æ‹–æ›³ï½œå¦‚æœè·¯å µæ­»äº†ç›´æ¥é‡æ–°é–‹å§‹ï½œç¢°è«çˆ¾è¿ªæ–¯æœ‰ï¼’ç§’ç„¡æ•µæ™‚é–“</p>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="joystick-zone">
            <div id="joystick-knob"></div>
        </div>

        <div id="ui-layer">
            <div id="start-screen">
                <img id="start-slime-icon" src="Slime.png" style="width:80px; image-rendering: pixelated;">
                <h2>å²èŠå§†çš„ç™‚ç™’å¤§ä½œæˆ°</h2>
                <p>é­”ç‹å¤§äººæ­£ç‚ºäº†åŸå ¡ç ´çˆ›è€Œç…©æƒ±...<br>èº«ç‚ºè²¼å¿ƒå¯µç‰©çš„ä½ ï¼Œæ±ºå®šæ½›å…¥é­”ç‹æˆ¿é–“çµ¦ä»–ä¸€å€‹æ“æŠ±ï¼<br>ç›®æ¨™ï¼šå³ä¸‹è§’é­”ç‹æˆ¿é–“</p>
                <button onclick="startGame()">é–‹å§‹æ½›è¡Œ</button>
            </div>
            
            <div id="game-over-screen" class="hidden">
                <img id="fail-portrait" class="npc-portrait" src="">
                <h2 style="color: #ff4d4d">è¢«ç™¼ç¾äº†ï¼</h2>
                <p id="fail-reason">NPC å°è©...</p>
                <button onclick="startGame()">é‡æ–°æŒ‘æˆ°</button>
            </div>

            <div id="win-screen" class="hidden">
                <img id="win-slime-icon" src="Slime.png" style="width:80px; image-rendering: pixelated;">
                <h2 style="color: #ffcc00">ä»»å‹™å®Œæˆï¼</h2>
                <p id="win-msg">ä½ æˆåŠŸé‘½é€²äº†é­”ç‹å¤§äººçš„æ‡·è£¡ï¼</p>
                <button onclick="startGame()">å†ç©ä¸€æ¬¡</button>
            </div>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- éŠæˆ²åƒæ•¸è¨­å®š ---
let TILE_SIZE = 40; 
const COLS = 20;
const ROWS = 15;
const PLAYER_SPEED = 3; 
const SAFE_ZONE_TILES = 4; 
const BOSS_ROOM_TILES = 4; 

// åœ–ç‰‡è³‡æº
const assets = {
    slime: { src: 'Slime.png', img: null },
    aaron: { src: 'ARON.png', img: null },
    carlos: { src: 'CAROS.png', img: null },
    ed: { src: 'ed.png', img: null },
    elaine: { src: 'ELAN.png', img: null },
    mordees: { src: 'MORDEES.png', img: null },
    wall: { src: 'wall.png', img: null },
    floor: { src: 'floor.jpg', img: null }
};

let loadedCount = 0;
const totalAssets = Object.keys(assets).length;
for (let key in assets) {
    const img = new Image();
    img.src = assets[key].src;
    img.onload = () => { loadedCount++; };
    assets[key].img = img;
}

// éŠæˆ²ç‹€æ…‹
let gameState = 'MENU'; 
let map = []; 
let player = { x: 0, y: 0, vx: 0, vy: 0, invincible: false, invincibleTimer: 0 };
let npcs = [];
let mordees = { active: false, x: 0, y: 0, timer: 0, text: "", bubbleTimer: 0 };
let bossRoomBubble = { text: "", timer: 0, visible: false };

// --- NPC è¨­å®š ---
const NPC_CONFIG = {
    ED: { 
        name: 'è‰¾å¾·', speed: 0.8, fov: 70, range: 180, color: 'rgba(150, 100, 255, 0.4)', imgKey: 'ed', 
        bubbleTexts: ["é€™å€‹æœˆåˆè¦åƒåœŸäº†", "æˆ‘è©²æ‹¿ç§æˆ¿éŒ¢å‡ºä¾†å—ï¼Ÿ", "é‚£è£¡çš„ç‰†å£åˆå¡Œäº†â€¦"],
        msgs: ["ã€Œå²èŠå§†å¤§äººï¼Œæ‚¨é€™æ˜¯è¦å»å“ªå•Šï¼Ÿã€", "ã€Œå”‰ï¼Œåœ°æ¿åˆé«’äº†ï¼Œè«‹ä¸è¦éš¨è™•äº‚è·‘ã€‚ã€", "ã€Œç¾åœ¨ä¸æ˜¯ç©è€çš„æ™‚é–“ï¼Œè«‹å›å§ã€‚ã€"]
    },
    CARLOS: { 
        name: 'å¡æ´›æ–¯', speed: 2.5, fov: 30, range: 220, color: 'rgba(255, 50, 50, 0.4)', imgKey: 'carlos', 
        bubbleTexts: ["æˆ‘è¦è®Šå¼·ï¼", "ä¸èƒ½å»æ‰¾é­”ç‹å¤§äººå—ï¼Ÿ", "è‚šå­å¥½é¤“å–”"],
        msgs: ["ã€Œä¸å‡†å»æ‰“æ“¾é­”ç‹å¤§äººï¼å›å»ï¼ã€", "ã€Œå“¼ï¼Œæƒ³æºœéå»ï¼Ÿé‚„æ—©äº†ä¸€ç™¾å¹´ï¼ã€", "ã€Œé€™è£¡ç¦æ­¢é€šè¡Œï¼å»å»å»ï¼Œä¸€é‚Šç©å»ã€‚ã€"]
    },
    ELAINE: { 
        name: 'ä¼ŠèŠæ©', speed: 1.0, fov: 50, range: 200, color: 'rgba(100, 200, 255, 0.4)', imgKey: 'elaine', 
        bubbleTexts: ["é­”ç‹å¤§äººæœ‰åƒé£¯å—ï¼Ÿ", "è©²é€é»å¿ƒçµ¦é­”ç‹å¤§äºº", "é­”ç‹å¤§äººæœ‰ä¼‘æ¯å—ï¼Ÿ"],
        msgs: ["ã€Œå²èŠå§†å¤§äººï¼Œé€™è£¡ä¸èƒ½é€šéå–”â€¦â€¦ã€", "ã€Œç‚ºäº†å¤§äººçš„å®‰å¯§ï¼Œè«‹æ‚¨å®‰éœä¸€é»ã€‚ã€", "ã€Œé€™å¯ä¸è¡Œï¼Œè¢«ç™¼ç¾çš„è©±æˆ‘æœƒå¾ˆå›°æ“¾çš„ã€‚ã€"]
    },
    AARON: { 
        name: 'å‹‡è€…äºå€«', speed: 1.5, fov: 45, range: 190, color: 'rgba(255, 200, 0, 0.4)', imgKey: 'aaron', 
        bubbleTexts: ["é€™è£¡æ˜¯å“ªè£¡ï¼Ÿ", "é­”ç‹çš„æˆ¿é–“åœ¨å“ªï¼Ÿ", "è¿·è·¯äº†â€¦â€¦"],
        msgs: ["ã€Œå—šå“‡ï¼å²èŠå§†ï¼...æŠ±æ­‰ï¼Œæˆ‘æ¢ä»¶åå°„æ‹”åŠäº†ã€‚ã€", "ã€Œæ¬¸ï¼Ÿç­‰ç­‰ï¼Œé­”ç‹çš„æˆ¿é–“æ˜¯åœ¨é€™é‚Šå—ï¼Ÿã€", "ã€Œåˆ¥æ“‹è·¯ï¼Œå°å‚¢ä¼™ï¼Œæˆ‘è¦å»è¨ä¼é­”ç‹ï¼ã€"]
    }
};

const MORDEES_TEXTS = ["å¥½é–’å–”~", "å¥½ç„¡èŠå–”", "å°é­”ç‹ç¾åœ¨åœ¨åšä»€éº¼å‘€?", "å‘¼å“‡~ (æ‰“å“ˆæ¬ )", "é€™è£¡æœ‰è—å¯¶è—å—?", "å“å‘€ï¼Œè¢«ç™¼ç¾äº†å—?", "ç•¶å‰ä»»é­”ç‹çœŸè¼•é¬†~"];
const BOSS_ROOM_TEXTS = ["å¥½ç´¯å–”â€¦â€¦", "å¥½æƒ³è€å»¢â€¦â€¦", "å‹‡è€…æ€éº¼é‚„ä¸ä¾†â€¦â€¦", "æƒ³åƒå¸ƒä¸â€¦â€¦", "åˆæ˜¯èµ¤å­—â€¦â€¦"];
const WIN_MSGS = [
    "ä½ æˆåŠŸé‘½é€²äº†é­”ç‹å¤§äººçš„æ‡·è£¡ï¼é­”ç‹å¤§äººè¢«ç™‚ç™’äº†ï¼",
    "é­”ç‹å¤§äººæŠ±èµ·ä½ ï¼šã€Œåªæœ‰ä½ æœ€æ‡‚æˆ‘äº†ï½ã€",
    "é­”ç‹å¤§äººæ‘¸æ‘¸ä½ çš„é ­ï¼Œä»Šå¤©çš„ç–²å‹å…¨æ¶ˆäº†ï¼",
    "ä½ è®Šæˆäº†é­”ç‹å¤§äººçš„å°ˆå±¬é æ•ï¼Œè»Ÿå‘¼å‘¼çš„çœŸèˆ’æœï¼",
    "é­”ç‹å¤§äººç¬‘äº†ï¼šã€Œæ˜¯ä½ å•Šï¼Œå°å‚¢ä¼™ï¼Œè¬è¬ä½ ä¾†çœ‹æˆ‘ã€‚ã€"
];

// --- NPC æ´»å‹•å€åŸŸ ---
const NPC_ZONES = [
    { minX: 4, maxX: 9, minY: 1, maxY: 7 },   // Zone 1: å·¦ä¸Šé™„è¿‘
    { minX: 10, maxX: 18, minY: 1, maxY: 7 }, // Zone 2: å³ä¸Š/ä¸­é–“
    { minX: 1, maxX: 9, minY: 8, maxY: 13 },  // Zone 3: å·¦ä¸‹
    { minX: 10, maxX: 15, minY: 8, maxY: 13 } // Zone 4: ä¸­ä¸‹
];

function resizeCanvas() {
    const container = document.getElementById('game-container');
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
}
window.addEventListener('resize', resizeCanvas);

// --- åˆ·æ–°åœ°åœ–åŠŸèƒ½ ---
function resetMap() {
    if (gameState !== 'PLAYING') return; // åªæœ‰åœ¨éŠæˆ²é€²è¡Œä¸­æ‰å…è¨±åˆ·æ–°
    generateMap();
    spawnEntities();
    // é‡ç½®ç©å®¶é€Ÿåº¦ï¼Œé¿å…æ®˜ç•™æ…£æ€§
    player.vx = 0;
    player.vy = 0;
    joystick.x = 0;
    joystick.y = 0;
    joystick.active = false;
    joystickKnob.style.transform = `translate(-50%, -50%)`;
}

function startGame() {
    if (loadedCount < totalAssets) { alert("åœ–ç‰‡è¼‰å…¥ä¸­ï¼Œè«‹ç¨å¾Œ..."); return; }
    resizeCanvas();
    document.getElementById('ui-layer').classList.add('hidden');
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('win-screen').classList.add('hidden');
    
    // é¡¯ç¤ºåˆ·æ–°æŒ‰éˆ•
    document.getElementById('reset-btn').style.display = 'block';

    generateMap();
    spawnEntities();
    
    gameState = 'PLAYING';
    gameLoop();
}

/**
 * åœ°åœ–ç”Ÿæˆ 
 */
function generateMap() {
    map = [];
    const bossEntranceSide = Math.random() > 0.5 ? 'LEFT' : 'TOP';

    for (let y = 0; y < ROWS; y++) {
        let row = [];
        for (let x = 0; x < COLS; x++) {
            if (x === 0 || x === COLS - 1 || y === 0 || y === ROWS - 1) {
                row.push(1);
            } 
            else if (x >= COLS - BOSS_ROOM_TILES && y >= ROWS - BOSS_ROOM_TILES) {
                let isLeftWall = (x === COLS - BOSS_ROOM_TILES);
                let isTopWall = (y === ROWS - BOSS_ROOM_TILES);

                if (isLeftWall || isTopWall) {
                    let isEntrance = false;
                    if (bossEntranceSide === 'LEFT' && isLeftWall && y === ROWS - 2) isEntrance = true;
                    if (bossEntranceSide === 'TOP' && isTopWall && x === COLS - 2) isEntrance = true;
                    
                    if (isEntrance) row.push(0); 
                    else row.push(1);
                } else {
                    row.push(0);
                }
            }
            else {
                if (x < SAFE_ZONE_TILES && y < SAFE_ZONE_TILES) row.push(0); 
                else row.push(Math.random() < 0.2 ? 1 : 0); 
            }
        }
        map.push(row);
    }
}

function spawnEntities() {
    player.x = TILE_SIZE * 1.5;
    player.y = TILE_SIZE * 1.5;
    player.invincible = false;
    player.invincibleTimer = 0;

    npcs = [];
    const availableTypes = [NPC_CONFIG.ED, NPC_CONFIG.CARLOS, NPC_CONFIG.ELAINE, NPC_CONFIG.AARON];
    for (let i = availableTypes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [availableTypes[i], availableTypes[j]] = [availableTypes[j], availableTypes[i]];
    }
    
    for (let i = 0; i < 4; i++) {
        let zone = NPC_ZONES[i];
        let type = availableTypes[i];
        let pos = getRandomFreePositionInZone(zone);
        
        npcs.push({
            x: pos.x, y: pos.y, type: type,
            angle: Math.random() * Math.PI * 2,
            moveTimer: 0, moveDir: Math.random() * Math.PI * 2,
            bubbleTimer: Math.random() * 120, 
            isBubbleVisible: false,
            currentBubbleText: "",
            zone: zone
        });
    }

    let mPos = getRandomFreePositionGlobal(); 
    mordees = {
        active: true, x: mPos.x, y: mPos.y,
        timer: 120, text: getRandomText(), bubbleTimer: 60
    };
    
    bossRoomBubble = { text: "", timer: 200, visible: false };
}

function getRandomText() {
    return MORDEES_TEXTS[Math.floor(Math.random() * MORDEES_TEXTS.length)];
}

function getRandomFreePositionInZone(zone) {
    let x, y;
    let maxAttempts = 100;
    do {
        x = Math.floor(Math.random() * (zone.maxX - zone.minX + 1)) + zone.minX;
        y = Math.floor(Math.random() * (zone.maxY - zone.minY + 1)) + zone.minY;
        if (map[y][x] !== 1) return { x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2 };
        maxAttempts--;
    } while (maxAttempts > 0);
    return { x: (zone.minX + (zone.maxX-zone.minX)/2) * TILE_SIZE, y: (zone.minY + (zone.maxY-zone.minY)/2) * TILE_SIZE };
}

function getRandomFreePositionGlobal() {
    let x, y;
    do {
        x = Math.floor(Math.random() * (COLS - 2)) + 1;
        y = Math.floor(Math.random() * (ROWS - 2)) + 1;
        let inSafeZone = (x < SAFE_ZONE_TILES && y < SAFE_ZONE_TILES);
        let inBossRoom = (x >= COLS - BOSS_ROOM_TILES && y >= ROWS - BOSS_ROOM_TILES);
        if (inSafeZone || inBossRoom) continue;
        if (map[y][x] !== 1) return { x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2 };
    } while (true);
}

function gameLoop() {
    if (gameState !== 'PLAYING') return;
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

function update() {
    // --- ç©å®¶ç§»å‹• ---
    let moveX = 0;
    let moveY = 0;
    
    if (keys['ArrowUp'] || keys['w']) moveY = -1;
    if (keys['ArrowDown'] || keys['s']) moveY = 1;
    if (keys['ArrowLeft'] || keys['a']) moveX = -1;
    if (keys['ArrowRight'] || keys['d']) moveX = 1;

    if (joystick.active) {
        moveX = joystick.x;
        moveY = joystick.y;
    }

    if (moveX !== 0 || moveY !== 0) {
        let len = Math.sqrt(moveX*moveX + moveY*moveY);
        if (len > 1) { moveX /= len; moveY /= len; } 
        
        let nextX = player.x + moveX * PLAYER_SPEED;
        let nextY = player.y + moveY * PLAYER_SPEED;
        
        if (!isWall(nextX, player.y)) player.x = nextX;
        if (!isWall(player.x, nextY)) player.y = nextY;
        
        player.x = Math.max(20, Math.min(COLS * TILE_SIZE - 20, player.x));
        player.y = Math.max(20, Math.min(ROWS * TILE_SIZE - 20, player.y));
    }

    if (player.invincible) {
        player.invincibleTimer--;
        if (player.invincibleTimer <= 0) player.invincible = false;
    }

    // --- è«çˆ¾è¿ªæ–¯ ---
    if (mordees.active) {
        if (dist(player.x, player.y, mordees.x, mordees.y) < 30) {
            player.invincible = true;
            player.invincibleTimer = 120; 
            let newPos = getRandomFreePositionGlobal();
            mordees.x = newPos.x; mordees.y = newPos.y;
            mordees.timer = 120;
            mordees.text = "å“å‘€~";
            mordees.bubbleTimer = 60;
        }
        mordees.timer--;
        if (mordees.timer <= 0) {
            let newPos = getRandomFreePositionGlobal();
            mordees.x = newPos.x; mordees.y = newPos.y;
            mordees.timer = 120;
            mordees.text = getRandomText();
            mordees.bubbleTimer = 90;
        }
        if (mordees.bubbleTimer > 0) mordees.bubbleTimer--;
    }

    // --- é­”ç‹æˆ¿é–“æ°£æ³¡ ---
    if (bossRoomBubble.timer > 0) bossRoomBubble.timer--;
    else {
        if (!bossRoomBubble.visible) {
            if (Math.random() < 0.01) {
                bossRoomBubble.text = BOSS_ROOM_TEXTS[Math.floor(Math.random() * BOSS_ROOM_TEXTS.length)];
                bossRoomBubble.visible = true;
                bossRoomBubble.timer = 150;
            }
        } else {
            bossRoomBubble.visible = false;
            bossRoomBubble.timer = 200;
        }
    }

    // --- å‹åˆ©æª¢æŸ¥ ---
    if (player.x > (COLS - 3) * TILE_SIZE && player.y > (ROWS - 3) * TILE_SIZE) {
        gameWin();
        return;
    }

    // --- NPC é‚è¼¯ ---
    for (let npc of npcs) {
        npc.moveTimer--;
        if (npc.moveTimer <= 0) {
            npc.moveDir = Math.random() * Math.PI * 2;
            npc.moveTimer = 60 + Math.random() * 60;
        }
        let nx = npc.x + Math.cos(npc.moveDir) * npc.type.speed;
        let ny = npc.y + Math.sin(npc.moveDir) * npc.type.speed;
        
        if (isValidNpcPos(nx, ny) && isInsideZone(nx, ny, npc.zone)) {
            npc.x = nx;
            npc.y = ny;
            let targetAngle = npc.moveDir;
            npc.angle = lerpAngle(npc.angle, targetAngle, 0.1);
        } else {
            npc.moveTimer = 0; 
        }

        npc.bubbleTimer--;
        if (npc.bubbleTimer <= 0) {
            if (npc.isBubbleVisible) {
                npc.isBubbleVisible = false;
                npc.bubbleTimer = 120 + Math.random() * 120; 
            } else {
                npc.isBubbleVisible = true;
                let texts = npc.type.bubbleTexts;
                npc.currentBubbleText = texts[Math.floor(Math.random() * texts.length)];
                npc.bubbleTimer = 120; 
            }
        }

        if (!player.invincible) {
            let playerInSafeZone = (player.x < SAFE_ZONE_TILES * TILE_SIZE && player.y < SAFE_ZONE_TILES * TILE_SIZE);
            if (!playerInSafeZone) {
                if (checkDetection(npc, player)) {
                    gameOver(npc);
                    return;
                }
                if (dist(player.x, player.y, npc.x, npc.y) < 25) {
                    gameOver(npc);
                    return;
                }
            }
        }
    }
}

function isInsideZone(x, y, zone) {
    let gx = x / TILE_SIZE;
    let gy = y / TILE_SIZE;
    return (gx >= zone.minX && gx <= zone.maxX + 1 && gy >= zone.minY && gy <= zone.maxY + 1);
}

function isValidNpcPos(x, y) {
    if (isWall(x, y)) return false;
    if (x < SAFE_ZONE_TILES * TILE_SIZE && y < SAFE_ZONE_TILES * TILE_SIZE) return false;
    if (x > (COLS - BOSS_ROOM_TILES) * TILE_SIZE && y > (ROWS - BOSS_ROOM_TILES) * TILE_SIZE) return false;
    return true;
}

function draw() {
    const mapW = COLS * TILE_SIZE;
    const mapH = ROWS * TILE_SIZE;
    const scale = Math.min(canvas.width / mapW, canvas.height / mapH);
    const offsetX = (canvas.width - mapW * scale) / 2;
    const offsetY = (canvas.height - mapH * scale) / 2;

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    if (assets.floor.img) {
        const pattern = ctx.createPattern(assets.floor.img, 'repeat');
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, mapW, mapH);
    } else {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, mapW, mapH);
    }

    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            let px = x * TILE_SIZE;
            let py = y * TILE_SIZE;
            if (map[y][x] === 1) {
                if (assets.wall.img) {
                    ctx.drawImage(assets.wall.img, px, py, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = '#444';
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                }
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(px + TILE_SIZE-5, py, 5, TILE_SIZE);
                ctx.fillRect(px, py + TILE_SIZE-5, TILE_SIZE, 5);
            } else {
                if (x < SAFE_ZONE_TILES && y < SAFE_ZONE_TILES) {
                    ctx.fillStyle = 'rgba(100, 255, 100, 0.2)'; 
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                }
                else if (x > COLS - BOSS_ROOM_TILES && y > ROWS - BOSS_ROOM_TILES) {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.3)'; 
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                }
            }
        }
    }

    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.fillText("é­”ç‹æˆ¿é–“", (COLS-2.5)*TILE_SIZE, (ROWS-2.5)*TILE_SIZE);

    if (bossRoomBubble.visible) {
        drawBubble((COLS-2)*TILE_SIZE, (ROWS-2)*TILE_SIZE, bossRoomBubble.text, true, false);
    }

    if (mordees.active) {
        ctx.drawImage(assets.mordees.img, mordees.x - 16, mordees.y - 16, 32, 32);
        drawBubble(mordees.x, mordees.y, mordees.text, mordees.bubbleTimer > 0);
    }

    for (let npc of npcs) {
        if (!player.invincible) drawVisionCone(npc);
        
        ctx.save();
        ctx.translate(npc.x, npc.y);
        if (Math.cos(npc.angle) < 0) ctx.scale(-1, 1);
        ctx.drawImage(assets[npc.type.imgKey].img, -20, -20, 40, 40);
        ctx.restore();

        drawBubble(npc.x, npc.y, npc.currentBubbleText, npc.isBubbleVisible, false);
    }

    ctx.save();
    ctx.translate(player.x, player.y);
    if (player.invincible) {
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, 25, 0, Math.PI*2);
        ctx.strokeStyle = 'gold';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText((player.invincibleTimer/60).toFixed(1), -10, -25);
    }
    let animScale = 1 + Math.sin(Date.now() / 100) * 0.05;
    ctx.scale(animScale, 1/animScale);
    ctx.drawImage(assets.slime.img, -16, -16, 32, 32);
    ctx.restore();
    
    if (player.x < SAFE_ZONE_TILES * TILE_SIZE && player.y < SAFE_ZONE_TILES * TILE_SIZE) {
        ctx.fillStyle = '#4caf50';
        ctx.font = 'bold 16px Microsoft JhengHei';
        ctx.fillText("å®‰å…¨å€", 20, 30);
    }

    ctx.restore();
}

function drawBubble(x, y, text, visible, isPermanent = false) {
    if (!visible || !text) return;
    
    ctx.save();
    ctx.font = 'bold 16px Microsoft JhengHei'; 
    let width = ctx.measureText(text).width + 20; 
    let height = 34; 
    let yOffset = -60; 

    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    ctx.shadowBlur = 5;
    ctx.shadowColor = "rgba(0,0,0,0.3)";
    ctx.fillRect(x - width/2, y + yOffset, width, height);
    ctx.shadowBlur = 0; 

    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2; 
    ctx.strokeRect(x - width/2, y + yOffset, width, height);
    
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y + yOffset + height/2);
    
    ctx.beginPath();
    ctx.moveTo(x, y + yOffset + height);
    ctx.lineTo(x - 6, y + yOffset + height + 8); 
    ctx.lineTo(x + 6, y + yOffset + height);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    ctx.fill();
    ctx.stroke(); 
    ctx.restore();
}

function isWall(x, y) {
    let gx = Math.floor(x / TILE_SIZE);
    let gy = Math.floor(y / TILE_SIZE);
    if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return true;
    return map[gy][gx] === 1;
}

function drawVisionCone(npc) {
    ctx.save();
    ctx.translate(npc.x, npc.y);
    ctx.rotate(npc.angle);
    
    ctx.fillStyle = npc.type.color;
    
    const rays = 50;
    const fovRad = npc.type.fov * Math.PI / 180;
    const halfFov = fovRad / 2;
    const step = fovRad / rays;

    ctx.beginPath();
    ctx.moveTo(0, 0);

    for (let i = -halfFov; i <= halfFov; i += step) {
        let hitDist = npc.type.range;
        
        for (let d = 0; d < npc.type.range; d += 5) {
            const worldAngle = npc.angle + i;
            const checkX = npc.x + Math.cos(worldAngle) * d;
            const checkY = npc.y + Math.sin(worldAngle) * d;
            
            if (isWall(checkX, checkY)) {
                hitDist = d;
                break;
            }
        }
        ctx.lineTo(Math.cos(i) * hitDist, Math.sin(i) * hitDist);
    }
    
    ctx.lineTo(0, 0);
    ctx.fill();
    ctx.restore();
}

function checkDetection(npc, player) {
    let d = dist(npc.x, npc.y, player.x, player.y);
    if (d > npc.type.range) return false;

    let dx = player.x - npc.x;
    let dy = player.y - npc.y;
    let angleToPlayer = Math.atan2(dy, dx);
    let angleDiff = angleToPlayer - npc.angle;
    while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

    let halfFov = (npc.type.fov * Math.PI / 180) / 2;
    
    if (Math.abs(angleDiff) <= halfFov) {
        let steps = Math.ceil(d / 10); 
        for (let i = 1; i < steps; i++) {
            let t = i / steps;
            let checkX = npc.x + dx * t;
            let checkY = npc.y + dy * t;
            if (isWall(checkX, checkY)) return false;
        }
        return true;
    }
    return false;
}

function dist(x1, y1, x2, y2) { return Math.sqrt((x1-x2)**2 + (y1-y2)**2); }
function lerpAngle(a, b, t) {
    let diff = b - a;
    while (diff <= -Math.PI) diff += Math.PI * 2;
    while (diff > Math.PI) diff -= Math.PI * 2;
    return a + diff * t;
}

function gameOver(npc) {
    gameState = 'GAMEOVER';
    joystick.active = false;
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('fail-portrait').src = assets[npc.type.imgKey].src;
    let randomMsg = npc.type.msgs[Math.floor(Math.random() * npc.type.msgs.length)];
    document.getElementById('fail-reason').innerText = randomMsg;
    
    // éš±è—åˆ·æ–°æŒ‰éˆ•
    document.getElementById('reset-btn').style.display = 'none';
}

function gameWin() {
    gameState = 'WIN';
    joystick.active = false;
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('win-screen').classList.remove('hidden');
    document.getElementById('win-msg').innerText = WIN_MSGS[Math.floor(Math.random() * WIN_MSGS.length)];
    
    // éš±è—åˆ·æ–°æŒ‰éˆ•
    document.getElementById('reset-btn').style.display = 'none';
}

const keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; updatePlayerVel(); });
window.addEventListener('keyup', e => { keys[e.key] = false; updatePlayerVel(); });
function updatePlayerVel() {
    player.vx = 0; player.vy = 0;
    if (keys['ArrowUp'] || keys['w']) player.vy = -1;
    if (keys['ArrowDown'] || keys['s']) player.vy = 1;
    if (keys['ArrowLeft'] || keys['a']) player.vx = -1;
    if (keys['ArrowRight'] || keys['d']) player.vx = 1;
}

const joystickZone = document.getElementById('joystick-zone');
const joystickKnob = document.getElementById('joystick-knob');
let joystick = { active: false, x: 0, y: 0, originX: 0, originY: 0 };

joystickZone.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = joystickZone.getBoundingClientRect();
    joystick.originX = rect.left + rect.width / 2;
    joystick.originY = rect.top + rect.height / 2;
    joystick.active = true;
    updateJoystick(touch.clientX, touch.clientY);
});

joystickZone.addEventListener('touchmove', e => {
    e.preventDefault();
    if (joystick.active) {
        const touch = e.touches[0];
        updateJoystick(touch.clientX, touch.clientY);
    }
});

joystickZone.addEventListener('touchend', e => {
    e.preventDefault();
    joystick.active = false;
    joystick.x = 0;
    joystick.y = 0;
    joystickKnob.style.transform = `translate(-50%, -50%)`;
});

function updateJoystick(clientX, clientY) {
    const maxDist = 35; 
    let dx = clientX - joystick.originX;
    let dy = clientY - joystick.originY;
    let dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
    }
    
    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    joystick.x = dx / maxDist;
    joystick.y = dy / maxDist;
}

function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else {
        document.exitFullscreen();
    }
}

resizeCanvas();

</script>
</body>
</html>
